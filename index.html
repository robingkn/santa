<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jingle Jump: Santa's Epic Quest</title>
    <style>
        /* No external deps: system fonts only */
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050b1a;
            font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
            user-select: none;
            touch-action: manipulation;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #050b1a;
        }

        #game-wrapper {
            position: relative;
            width: min(800px, 100vw, 100vh * 4/3);
            height: min(600px, 100vh, 100vw * 3/4);
            max-width: 800px;
            max-height: 600px;
            box-shadow: 0 0 80px rgba(0, 0, 0, 0.8);
        }

        /* Fullscreen: game fills full width and height */
        #game-container:fullscreen,
        #game-container:-webkit-full-screen {
            width: 100%;
            height: 100%;
        }

        #game-container:fullscreen #game-wrapper,
        #game-container:-webkit-full-screen #game-wrapper {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
        }

        #game-wrapper canvas,
        #game-wrapper .speed-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #game-wrapper #gameCanvas {
            width: 100%;
            height: 100%;
        }

        #game-wrapper #speedCanvas {
            width: 100%;
            height: 100%;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #0a1931 0%, #16213e 50%, #1a1a2e 100%);
            box-shadow: inset 0 0 200px rgba(255, 255, 255, 0.02);
        }

        #ui {
            position: absolute;
            top: max(12px, env(safe-area-inset-top));
            left: max(12px, env(safe-area-inset-left));
            right: max(12px, env(safe-area-inset-right));
            color: #fff;
            pointer-events: none;
            text-shadow: 3px 3px 8px rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 10;
        }

        .stat {
            font-size: clamp(16px, 4vmin, 28px);
            font-weight: 800;
            margin-bottom: 2px;
            letter-spacing: 1px;
            font-family: Georgia, 'Times New Roman', serif;
        }

        .stat span {
            display: inline-block;
            transition: transform 0.2s;
        }

        .stat span.score-pulse {
            animation: scorePulse 0.4s ease-out;
        }

        @keyframes scorePulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.4);
                color: #ffd700;
            }
        }

        #level-info {
            text-align: right;
        }

        .meter-container {
            width: min(200px, 45vw);
            height: clamp(12px, 2.5vmin, 18px);
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 2px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }







        #health-container {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .heart {
            width: clamp(18px, 4vmin, 25px);
            height: clamp(18px, 4vmin, 25px);
            background: #d42426;
            transform: rotate(45deg);
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            animation: heartBeat 1.5s ease-in-out infinite;
        }

        @keyframes heartBeat {

            0%,
            100% {
                transform: rotate(45deg) scale(1);
            }

            50% {
                transform: rotate(45deg) scale(1.05);
            }
        }

        .heart::before,
        .heart::after {
            content: '';
            width: clamp(18px, 4vmin, 25px);
            height: clamp(18px, 4vmin, 25px);
            background: #d42426;
            border-radius: 50%;
            position: absolute;
        }

        .heart::before {
            left: -50%;
        }

        .heart::after {
            top: -50%;
        }

        .heart.lost {
            opacity: 0.2;
            background: #333;
            animation: none;
        }

        .heart.lost::before,
        .heart.lost::after {
            background: #333;
        }

        #timer-display {
            font-size: clamp(18px, 4vmin, 32px);
            font-weight: 900;
            color: #00d2ff;
            text-shadow: 0 0 10px #00d2ff;
            font-family: Georgia, 'Times New Roman', serif;
        }

        #timer-display.warning {
            color: #ff4444;
            text-shadow: 0 0 15px #ff4444;
            animation: timerPulse 0.5s ease-in-out infinite;
        }

        @keyframes timerPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        #victory-screen,
        #game-over-screen,
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.95));
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            text-align: center;
            z-index: 100;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #start-screen h1,
        #victory-screen h1,
        #game-over-screen h1 {
            font-size: clamp(32px, 10vmin, 72px);
            margin-bottom: clamp(10px, 2vmin, 20px);
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #ff6b00;
            font-family: Georgia, 'Times New Roman', serif;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {

            0%,
            100% {
                text-shadow: 0 0 30px #ffd700, 0 0 60px #ff6b00;
            }

            50% {
                text-shadow: 0 0 50px #ffd700, 0 0 100px #ff6b00;
            }
        }

        .subtitle {
            font-size: clamp(16px, 3.5vmin, 24px);
            margin-bottom: clamp(16px, 3vmin, 30px);
            color: #00d2ff;
            font-weight: 600;
        }

        .final-stats {
            font-size: clamp(18px, 3.5vmin, 28px);
            margin: clamp(12px, 2vmin, 20px) 0;
            line-height: 1.8;
        }

        .final-stats strong {
            color: #00d2ff;
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vmin, 32px);
        }

        .button-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .game-btn {
            padding: clamp(12px, 2vmin, 18px) clamp(24px, 4vmin, 40px);
            background: linear-gradient(135deg, #d42426, #a01618);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: clamp(18px, 3.5vmin, 24px);
            cursor: pointer;
            font-family: Georgia, 'Times New Roman', serif;
            box-shadow: 0 6px 20px rgba(212, 36, 38, 0.6);
            transition: all 0.3s;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
        }

        .game-btn.secondary {
            background: linear-gradient(135deg, #00d2ff, #0096c7);
            box-shadow: 0 6px 20px rgba(0, 210, 255, 0.6);
        }

        .game-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(212, 36, 38, 0.8);
        }

        .game-btn.secondary:hover {
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.8);
        }

        .game-btn:active {
            transform: translateY(0);
        }

        #achievements {
            position: absolute;
            top: min(120px, 22vh);
            right: max(12px, env(safe-area-inset-right));
            text-align: right;
            pointer-events: none;
        }

        .achievement {
            background: rgba(0, 0, 0, 0.8);
            padding: clamp(8px, 1.5vmin, 12px) clamp(12px, 2.5vmin, 20px);
            border-radius: 8px;
            margin-bottom: 8px;
            border: 2px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            animation: achievementSlide 0.5s ease-out, achievementFade 3s ease-in 2s forwards;
            font-size: clamp(14px, 2.5vmin, 18px);
            font-weight: 800;
            color: #ffd700;
        }

        @keyframes achievementSlide {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes achievementFade {
            to {
                opacity: 0;
                transform: translateX(400px);
            }
        }

        #controls-hint {
            position: absolute;
            bottom: max(12px, env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: clamp(11px, 2.2vmin, 15px);
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        body.touch-device #controls-hint {
            display: none;
        }

        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 42%;
            min-height: 160px;
            max-height: 280px;
            padding: 0 max(20px, env(safe-area-inset-left)) max(16px, env(safe-area-inset-bottom)) max(20px, env(safe-area-inset-right));
            padding-bottom: max(24px, calc(env(safe-area-inset-bottom) + 12px));
            box-sizing: border-box;
            pointer-events: none;
            display: none;
            z-index: 20;
        }

        #touch-controls .touch-zone {
            pointer-events: auto;
            display: flex;
            gap: clamp(12px, 3vmin, 24px);
            align-items: center;
        }

        #touch-controls .touch-zone-left {
            position: absolute;
            left: max(16px, env(safe-area-inset-left));
            bottom: max(24px, env(safe-area-inset-bottom));
        }

        #touch-controls .touch-zone-right {
            position: absolute;
            right: max(16px, env(safe-area-inset-right));
            bottom: max(24px, env(safe-area-inset-bottom));
            flex-direction: column;
            gap: clamp(10px, 2vmin, 16px);
        }

        .touch-btn {
            width: clamp(56px, 14vmin, 88px);
            height: clamp(56px, 14vmin, 88px);
            min-width: 56px;
            min-height: 56px;
            background: rgba(255, 255, 255, 0.18);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            color: white;
            font-weight: bold;
            font-size: clamp(22px, 5vmin, 32px);
            transition: background 0.1s, transform 0.1s;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(8px);
            -webkit-tap-highlight-color: transparent;
        }

        .touch-btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.92);
        }

        .touch-btn.jump-btn {
            background: rgba(0, 210, 255, 0.25);
            border-color: rgba(0, 210, 255, 0.6);
        }

        #btn-fullscreen {
            position: absolute;
            top: max(8px, env(safe-area-inset-top));
            right: max(8px, env(safe-area-inset-right));
            width: clamp(36px, 8vmin, 44px);
            height: clamp(36px, 8vmin, 44px);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: clamp(18px, 4vmin, 22px);
            cursor: pointer;
            z-index: 25;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.2s;
        }

        #btn-fullscreen:hover {
            background: rgba(0, 0, 0, 0.6);
        }

        #btn-fullscreen:active {
            transform: scale(0.95);
        }

        #combo-display {
            position: absolute;
            top: min(120px, 22vh);
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(32px, 8vmin, 56px);
            font-weight: 900;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            opacity: 0;
            pointer-events: none;
            font-family: Georgia, 'Times New Roman', serif;
            z-index: 50;
        }

        #combo-display.show {
            animation: comboShow 1s ease-out;
        }

        @keyframes comboShow {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.5);
            }

            30% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1.3);
            }

            70% {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.8);
            }
        }



        .powerup-icon {
            position: absolute;
            font-size: 24px;
            pointer-events: none;
            animation: float 2s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        #jump-indicator {
            position: absolute;
            bottom: min(140px, 28vh);
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(14px, 2.5vmin, 20px);
            font-weight: 800;
            color: #00d2ff;
            text-shadow: 0 0 10px #00d2ff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        #jump-indicator.show {
            opacity: 1;
        }

        .instructions {
            max-width: min(600px, 92vw);
            text-align: left;
            background: rgba(0, 0, 0, 0.6);
            padding: clamp(12px, 2vmin, 20px) clamp(16px, 3vmin, 30px);
            border-radius: 12px;
            margin: clamp(10px, 2vmin, 20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .instructions h3 {
            color: #ffd700;
            margin-top: 0;
            font-family: Georgia, 'Times New Roman', serif;
            font-size: clamp(20px, 4vmin, 28px);
        }

        .instructions p {
            margin: 8px 0;
            line-height: 1.6;
            font-size: clamp(13px, 2.2vmin, 16px);
        }

        .icon-legend {
            display: inline-block;
            margin-right: 15px;
        }

        .speed-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .speed-lines.active {
            opacity: 0.3;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="game-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div class="speed-lines" id="speed-lines">
                <canvas id="speedCanvas" width="800" height="600"></canvas>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" style="display: flex;">
            <h1>üéÑ JINGLE JUMP üéÑ</h1>
            <div class="subtitle">Santa's Epic Christmas Quest</div>
            <div class="instructions">
                <h3>How to Play</h3>
                <p><strong>‚Üê ‚Üí</strong> Move | <strong>‚Üë</strong> Jump (Double Jump!) | <strong>X</strong> Snowball</p>
                <p><strong>Gifts & Stars:</strong> Collect ‚≠ê or üéÅ to increase your score!</p>
                <p><br></p>
                <p><span class="icon-legend">üéÅ = 100 pts</span> <span class="icon-legend">‚≠ê = 500 pts</span> <span
                        class="icon-legend">üîî = 500 pts</span></p>
                <p><span class="icon-legend">‚ö° Speed Boost</span> <span class="icon-legend">üõ°Ô∏è Shield</span> <span
                        class="icon-legend">‚ùÑÔ∏è Freeze Time</span></p>
                <p><br></p>
                <p>üí° <strong>Combos:</strong> Collect items quickly for multipliers!<br>
                    üí° <strong>Ice Platforms:</strong> Watch out - they're slippery!<br>
                    üí° <strong>Beat the clock:</strong> Faster completions = bonus points!</p>
            </div>
            <div class="button-container">
                <button class="game-btn" onclick="game.startGame()">START ADVENTURE</button>
            </div>
        </div>

        <!-- UI -->
        <div id="ui">
            <div>
                <div class="stat">SCORE: <span id="score">0</span></div>

                <div id="health-container">
                    <div class="heart"></div>
                    <div class="heart"></div>
                    <div class="heart"></div>
                </div>
            </div>
            <div id="level-info">
                <div class="stat" id="level-name">SNOW VILLAGE</div>
                <div style="font-size: 14px; color: rgba(255,255,255,0.8);">LEVEL <span id="level-num">1</span></div>
                <div id="timer-display">‚è±Ô∏è 0:00</div>
            </div>
        </div>

        <!-- Floating indicators -->
        <div id="combo-display">COMBO x3!</div>

        <div id="jump-indicator">DOUBLE JUMP READY!</div>
        <div id="achievements"></div>

        <div id="controls-hint">
            ‚Üê ‚Üí : Move | ‚Üë : Jump (x2) | X: Snowball
        </div>

        <!-- Fullscreen (tap/click, no extra key) -->
        <button type="button" id="btn-fullscreen" tabindex="-1" title="Full screen"
            aria-label="Toggle full screen">‚õ∂</button>

        <!-- Touch Controls: left = move, right = jump / shoot -->
        <div id="touch-controls">
            <div class="touch-zone touch-zone-left">
                <div id="btn-left" class="touch-btn" aria-label="Move left">‚Üê</div>
                <div id="btn-right" class="touch-btn" aria-label="Move right">‚Üí</div>
            </div>
            <div class="touch-zone touch-zone-right">
                <div id="btn-jump" class="touch-btn jump-btn" aria-label="Jump">‚Üë</div>
                <div id="btn-shoot" class="touch-btn" aria-label="Snowball">‚ùÑ</div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen">
            <h1>üéÑ CHRISTMAS SAVED! üéÑ</h1>
            <div class="final-stats">
                Final Score: <strong id="final-score">0</strong><br>
                Time: <strong id="final-time">0:00</strong><br>
                <span id="time-bonus"></span>
                <div id="achievement-list" style="margin-top: 20px;"></div>
            </div>
            <div class="button-container">
                <button class="game-btn" onclick="location.reload()">Play Again</button>
                <button class="game-btn secondary" onclick="game.startGame()">New Game</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h1>‚òÉÔ∏è TRY AGAIN! ‚òÉÔ∏è</h1>
            <div class="final-stats">
                Score: <strong id="gameover-score">0</strong><br>
                Level Reached: <strong id="gameover-level">1</strong><br>
                Santa needs more practice!
            </div>
            <div class="button-container">
                <button class="game-btn" onclick="location.reload()">Restart</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const CANVAS_WIDTH = 800, CANVAS_HEIGHT = 600;
        const GRAVITY = 0.5, FRICTION = 0.85, JUMP_FORCE = -14, MOVE_SPEED = 1.0, MAX_SPEED = 7;
        const SLIPPERY_FRICTION = 0.98;
        const COMBO_TIMEOUT = 2000;
        const DOUBLE_JUMP_FORCE = -12;

        const lerp = (a, b, t) => a + (b - a) * t;

        // --- AUDIO SYSTEM ---
        class AudioSystem {
            constructor() { this.ctx = null; this.masterGain = null; this.isStarted = false; }
            init() {
                if (this.isStarted) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain(); this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0.2; this.isStarted = true; this.startMusic();
            }
            playSfx(type, pitch = 1) {
                if (!this.ctx) return;
                const o = this.ctx.createOscillator(), g = this.ctx.createGain();
                o.connect(g); g.connect(this.masterGain); const n = this.ctx.currentTime;
                if (type === 'jump') {
                    o.type = 'triangle'; o.frequency.setValueAtTime(150 * pitch, n); o.frequency.exponentialRampToValueAtTime(400 * pitch, n + 0.1);
                    g.gain.setValueAtTime(0.3, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.2); o.start(); o.stop(n + 0.2);
                } else if (type === 'collect') {
                    o.type = 'sine'; o.frequency.setValueAtTime(800 * pitch, n); o.frequency.exponentialRampToValueAtTime(1200 * pitch, n + 0.05);
                    g.gain.setValueAtTime(0.2, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.3); o.start(); o.stop(n + 0.3);
                } else if (type === 'shoot') {
                    o.type = 'square'; o.frequency.setValueAtTime(400, n); o.frequency.exponentialRampToValueAtTime(100, n + 0.1);
                    g.gain.setValueAtTime(0.1, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.1); o.start(); o.stop(n + 0.1);
                } else if (type === 'hurt') {
                    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, n); o.frequency.exponentialRampToValueAtTime(50, n + 0.3);
                    g.gain.setValueAtTime(0.3, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.3); o.start(); o.stop(n + 0.3);
                } else if (type === 'power') {
                    o.type = 'sine'; o.frequency.setValueAtTime(600, n); o.frequency.exponentialRampToValueAtTime(1200, n + 0.2);
                    g.gain.setValueAtTime(0.15, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.5); o.start(); o.stop(n + 0.5);
                } else if (type === 'powerup') {
                    o.type = 'triangle';
                    [400, 600, 800].forEach((f, i) => {
                        o.frequency.setValueAtTime(f, n + i * 0.05);
                    });
                    g.gain.setValueAtTime(0.15, n); g.gain.exponentialRampToValueAtTime(0.01, n + 0.3); o.start(); o.stop(n + 0.3);
                } else if (type === 'achievement') {
                    const freqs = [523, 659, 784];
                    freqs.forEach((f, i) => {
                        const osc = this.ctx.createOscillator(), gn = this.ctx.createGain();
                        osc.connect(gn); gn.connect(this.masterGain);
                        osc.type = 'sine'; osc.frequency.setValueAtTime(f, n + i * 0.08);
                        gn.gain.setValueAtTime(0.15, n + i * 0.08); gn.gain.exponentialRampToValueAtTime(0.01, n + i * 0.08 + 0.3);
                        osc.start(n + i * 0.08); osc.stop(n + i * 0.08 + 0.3);
                    });
                } else if (type === 'victory') {
                    const notes = [523, 659, 784, 1047];
                    notes.forEach((freq, i) => {
                        const osc = this.ctx.createOscillator(), gn = this.ctx.createGain();
                        osc.connect(gn); gn.connect(this.masterGain);
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(freq, n + i * 0.15);
                        gn.gain.setValueAtTime(0.2, n + i * 0.15);
                        gn.gain.exponentialRampToValueAtTime(0.01, n + i * 0.15 + 0.4);
                        osc.start(n + i * 0.15); osc.stop(n + i * 0.15 + 0.4);
                    });
                }
            }
            startMusic() {
                const notes = [659, 659, 659, 0, 659, 659, 659, 0, 659, 784, 523, 587, 659, 0, 698, 698, 698, 698, 698, 659, 659, 659, 659, 587, 587, 659, 587, 0, 784];
                let cur = 0; const p = () => {
                    if (notes[cur] > 0) {
                        const o = this.ctx.createOscillator(), g = this.ctx.createGain();
                        o.type = 'triangle'; o.connect(g); g.connect(this.masterGain);
                        o.frequency.setValueAtTime(notes[cur], this.ctx.currentTime);
                        g.gain.setValueAtTime(0.04, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
                        o.start(); o.stop(this.ctx.currentTime + 0.4);
                    }
                    cur = (cur + 1) % notes.length; setTimeout(p, 200);
                }; p();
            }
        }
        const audio = new AudioSystem();

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(x, y, type, count = 5) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 2;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        life: 30 + Math.random() * 30,
                        maxLife: 60,
                        type,
                        size: Math.random() * 4 + 2,
                        color: type === 'collect' ? '#ffd700' :
                            type === 'speed' ? '#ff6b00' :
                                type === 'shield' ? '#4caf50' : '#fff'
                    });
                }
            }

            update() {
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2;
                    p.life--;
                    p.vx *= 0.98;
                });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            render(ctx, cam) {
                this.particles.forEach(p => {
                    const alpha = p.life / p.maxLife;
                    const screenX = (p.x - cam.x) * cam.z + 400;
                    const screenY = (p.y - cam.y) * cam.z + 300;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.size * cam.z, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        }

        // --- ACHIEVEMENT SYSTEM ---
        class AchievementSystem {
            constructor() {
                this.unlocked = new Set();
                this.achievements = {
                    'first_blood': { name: 'üéØ First Blood', desc: 'Defeat your first enemy' },
                    'combo_master': { name: 'üî• Combo Master', desc: 'Reach a 5x combo' },
                    'speed_demon': { name: '‚ö° Speed Demon', desc: 'Complete a level in under 30 seconds' },
                    'no_damage': { name: 'üõ°Ô∏è Untouchable', desc: 'Complete a level without taking damage' },
                };
            }

            unlock(key) {
                if (!this.unlocked.has(key) && this.achievements[key]) {
                    this.unlocked.add(key);
                    this.showAchievement(this.achievements[key]);
                    audio.playSfx('achievement');
                }
            }

            showAchievement(ach) {
                const div = document.createElement('div');
                div.className = 'achievement';
                div.innerHTML = `<div>${ach.name}</div><div style="font-size: 14px; font-weight: 600;">${ach.desc}</div>`;
                document.getElementById('achievements').appendChild(div);
                setTimeout(() => div.remove(), 5000);
            }

            getUnlocked() {
                return Array.from(this.unlocked).map(k => this.achievements[k]);
            }
        }

        // --- RENDERER ---
        class Renderer {
            static drawSanta(ctx, x, y, dir, state, animTime, hasShield) {
                ctx.save();
                ctx.translate(x, y);
                if (dir === -1) ctx.scale(-1, 1);

                const bounce = state === 'walking' ? Math.abs(Math.sin(animTime * 10)) * 5 : 0;
                ctx.rotate(state === 'walking' ? Math.sin(animTime * 10) * 0.1 : 0);
                ctx.translate(0, -bounce);

                // Shield
                if (hasShield) {
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5 + Math.sin(animTime * 20) * 0.2;
                    ctx.beginPath();
                    ctx.arc(0, -35, 45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }


                // Body
                ctx.fillStyle = '#d42426';
                ctx.beginPath();
                ctx.ellipse(0, -20, 15, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Belt
                ctx.fillStyle = '#111';
                ctx.fillRect(-15, -20, 30, 5);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-3, -20, 6, 5);

                // Head
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(8, -32, 12, 0, Math.PI * 2);
                ctx.fill();

                // Face
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(10, -35, 6, 0, Math.PI * 2);
                ctx.fill();

                // Eyes
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(8, -36, 1.5, 0, Math.PI * 2);
                ctx.arc(12, -36, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Hat
                ctx.fillStyle = '#d42426';
                ctx.beginPath();
                ctx.moveTo(0, -42);
                ctx.lineTo(15, -42);
                ctx.lineTo(5, -55);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(5, -55, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(0, -44, 16, 4);

                // Legs
                ctx.fillStyle = '#111';
                const s = state === 'walking' ? Math.sin(animTime * 10) * 10 : 0;
                ctx.fillRect(-10 + s, -5, 8, 8);
                ctx.fillRect(2 - s, -5, 8, 8);

                ctx.restore();
            }

            static drawPlatform(ctx, x, y, w, h, slippery) {
                const grad = ctx.createLinearGradient(x, y, x, y + h);
                grad.addColorStop(0, slippery ? '#5dade2' : '#2c3e50');
                grad.addColorStop(1, slippery ? '#2980b9' : '#1a252f');
                ctx.fillStyle = grad;
                ctx.fillRect(x, y, w, h);

                if (slippery) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(x, y, w, 5);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    for (let i = 0; i < w; i += 20) {
                        ctx.fillRect(x + i, y, 10, h);
                    }
                }

                ctx.fillStyle = slippery ? '#e8f4f8' : '#fff';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y);
                ctx.lineTo(x + w, y + 15);
                for (let i = w; i >= 0; i -= 20) {
                    ctx.quadraticCurveTo(x + i - 10, y + 25, x + i - 20, y + 15);
                }
                ctx.fill();
            }

            static drawTree(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x, y);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(-size / 10, -size / 5, size / 5, size / 5);
                ctx.fillStyle = '#1b5e20';
                for (let i = 0; i < 3; i++) {
                    const yp = -size / 5 - (i * size / 4);
                    const wd = size - (i * size / 4);
                    ctx.beginPath();
                    ctx.moveTo(-wd / 2, yp);
                    ctx.lineTo(wd / 2, yp);
                    ctx.lineTo(0, yp - size / 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            static drawItem(ctx, x, y, type) {
                ctx.save();
                ctx.translate(x, y);
                if (type === 'gift') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#e74c3c';
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(-12, -12, 24, 24);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-2, -12, 4, 24);
                    ctx.fillRect(-12, -2, 24, 4);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(-5, -15, 4, 0, Math.PI * 2);
                    ctx.arc(5, -15, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (type === 'star') {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#f1c40f';
                    ctx.fillStyle = '#f1c40f';
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(Math.cos(i * Math.PI * 2 / 5 - Math.PI / 2) * 15, Math.sin(i * Math.PI * 2 / 5 - Math.PI / 2) * 15);
                        ctx.lineTo(Math.cos((i + 0.5) * Math.PI * 2 / 5 - Math.PI / 2) * 7, Math.sin((i + 0.5) * Math.PI * 2 / 5 - Math.PI / 2) * 7);
                    }
                    ctx.fill();
                } else if (type === 'bell') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffd700';
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, Math.PI, 0);
                    ctx.lineTo(12, 10);
                    ctx.lineTo(-12, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#d4af37';
                    ctx.beginPath();
                    ctx.arc(0, 10, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }

            static drawPowerup(ctx, x, y, type) {
                ctx.save();
                ctx.translate(x, y);
                ctx.shadowBlur = 20;

                if (type === 'speed') {
                    ctx.shadowColor = '#ff6b00';
                    ctx.fillStyle = '#ff6b00';
                    ctx.beginPath();
                    ctx.moveTo(-15, 0);
                    ctx.lineTo(0, -12);
                    ctx.lineTo(15, 0);
                    ctx.lineTo(0, 12);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ö°', 0, 0);
                } else if (type === 'shield') {
                    ctx.shadowColor = '#4caf50';
                    ctx.fillStyle = '#4caf50';
                    ctx.beginPath();
                    ctx.moveTo(0, -15);
                    ctx.lineTo(12, -8);
                    ctx.lineTo(12, 8);
                    ctx.lineTo(0, 15);
                    ctx.lineTo(-12, 8);
                    ctx.lineTo(-12, -8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üõ°Ô∏è', 0, 0);
                } else if (type === 'freeze') {
                    ctx.shadowColor = '#00d2ff';
                    ctx.fillStyle = '#00d2ff';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * Math.PI) / 3;
                        const x = Math.cos(angle) * 12;
                        const y = Math.sin(angle) * 12;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ùÑÔ∏è', 0, 0);
                }

                ctx.restore();
            }

            static drawSnowman(ctx, x, y, size, frozen) {
                ctx.save();
                ctx.translate(x, y);
                if (frozen) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00d2ff';
                    ctx.globalAlpha = 0.6;
                }
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, -size / 3, size / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, -size * 0.7, size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(0, -size * 0.95, size / 6, 0, Math.PI * 2);
                ctx.fill();

                if (!frozen) {
                    ctx.fillStyle = '#111';
                    ctx.beginPath();
                    ctx.arc(-4, -size * 0.98, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(4, -size * 0.98, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Carrot nose
                    ctx.fillStyle = '#ff6b00';
                    ctx.beginPath();
                    ctx.moveTo(0, -size * 0.95);
                    ctx.lineTo(8, -size * 0.95);
                    ctx.lineTo(4, -size * 0.92);
                    ctx.fill();
                }

                ctx.restore();
            }

            static drawCabin(ctx, x, y, glowing) {
                ctx.save();
                ctx.translate(x, y);

                if (glowing) {
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffd700';
                }

                ctx.fillStyle = '#5d4037';
                ctx.fillRect(-40, -60, 80, 60);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(-10, -30, 20, 30);
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(5, -15, 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = glowing ? '#fff9c4' : '#8d6e63';
                ctx.shadowBlur = glowing ? 15 : 0;
                ctx.shadowColor = '#fff9c4';
                ctx.fillRect(-30, -45, 15, 15);
                ctx.fillRect(15, -45, 15, 15);
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#d42426';
                ctx.beginPath();
                ctx.moveTo(-50, -60);
                ctx.lineTo(50, -60);
                ctx.lineTo(0, -100);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(-50, -60);
                ctx.lineTo(50, -60);
                ctx.lineTo(40, -65);
                ctx.lineTo(-40, -65);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#8b4513';
                ctx.fillRect(20, -90, 15, 30);
                ctx.fillStyle = '#fff';
                ctx.fillRect(20, -92, 15, 4);

                ctx.restore();
            }

            static drawBackground(ctx, cam, level) {
                ctx.save();
                ctx.globalAlpha = 0.2;

                ctx.fillStyle = '#1a3a52';
                for (let i = 0; i < 5; i++) {
                    const x = i * 400 - (cam.x * 0.1);
                    ctx.beginPath();
                    ctx.moveTo(x - 100, 600);
                    const peak = 300 - (i * 11 + 7) % 50;
                    ctx.lineTo(x + 200, peak);
                    ctx.lineTo(x + 500, 600);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.globalAlpha = 0.3;
                for (let i = 0; i < 15; i++) {
                    const x = i * 200 - (cam.x * 0.2);
                    Renderer.drawTree(ctx, x, 520, 80);
                }

                ctx.restore();
            }
        }

        // --- LOGIC ---
        class Input {
            constructor() {
                this.keys = {};
                this.pressed = {};

                window.addEventListener('keydown', e => {
                    if (!this.keys[e.code]) {
                        this.pressed[e.code] = true;
                    }
                    this.keys[e.code] = true;
                    audio.init();
                });
                window.addEventListener('keyup', e => {
                    this.keys[e.code] = false;
                    this.pressed[e.code] = false;
                });

                if ('ontouchstart' in window) {
                    document.body.classList.add('touch-device');
                    document.getElementById('touch-controls').style.display = 'block';
                    const b = (id, k) => {
                        const btn = document.getElementById(id);
                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            this.keys[k] = true;
                            this.pressed[k] = true;
                            audio.init();
                        });
                        btn.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            this.keys[k] = false;
                            this.pressed[k] = false;
                        });
                    };
                    b('btn-left', 'ArrowLeft');
                    b('btn-right', 'ArrowRight');
                    b('btn-jump', 'Space');
                    b('btn-shoot', 'KeyX');
                }
            }

            isPressed(k) { return this.keys[k]; }

            justPressed(k) {
                const result = this.pressed[k];
                this.pressed[k] = false;
                return result;
            }
        }

        class Player {
            constructor(x, y) {
                this.reset(x, y);
            }

            reset(x, y) {
                this.x = x; this.y = y; this.w = 30; this.h = 50; this.vx = 0; this.vy = 0;
                this.dir = 1; this.state = 'idle'; this.animT = 0; this.onG = false;
                this.snowballs = []; this.shootCd = 0;
                this.health = 3; this.invincible = 0;
                this.combo = 0; this.comboTimer = 0;
                this.hasDoubleJump = true; this.hasUsedDoubleJump = false;
                this.speedBoost = 0; this.hasShield = 0;
                this.levelDamageTaken = 0;
            }

            update(input, world, particles, achievements) {
                if (!world || !world.platforms) return; // Safety check

                let speed = MOVE_SPEED, max = MAX_SPEED;
                let friction = FRICTION;

                // Check if on slippery platform
                if (this.onG) {
                    for (const p of world.platforms) {
                        if (p.s && this.x < p.x + p.w && this.x + this.w > p.x &&
                            this.y + this.h >= p.y && this.y + this.h <= p.y + 10) {
                            friction = SLIPPERY_FRICTION;
                            break;
                        }
                    }
                }

                // Power-ups
                if (this.speedBoost > 0) {
                    speed *= 2;
                    max *= 2;
                    this.speedBoost--;
                    document.getElementById('speed-lines').classList.add('active');
                } else {
                    document.getElementById('speed-lines').classList.remove('active');
                }

                if (this.hasShield > 0) {
                    this.hasShield--;
                }

                if (input.isPressed('ArrowLeft')) {
                    this.vx -= speed; this.dir = -1; this.state = 'walking';
                }
                else if (input.isPressed('ArrowRight')) {
                    this.vx += speed; this.dir = 1; this.state = 'walking';
                }
                else {
                    this.vx *= friction;
                    if (Math.abs(this.vx) < 0.1) this.state = 'idle';
                }

                if (Math.abs(this.vx) > max) this.vx = Math.sign(this.vx) * max;

                // Jump with double jump
                if (input.justPressed('Space') || input.justPressed('ArrowUp')) {
                    if (this.onG) {
                        this.vy = JUMP_FORCE;
                        this.hasUsedDoubleJump = false;
                        audio.playSfx('jump', 1);
                    } else if (this.hasDoubleJump && !this.hasUsedDoubleJump) {
                        this.vy = DOUBLE_JUMP_FORCE;
                        this.hasUsedDoubleJump = true;
                        audio.playSfx('jump', 1.3);
                        particles.emit(this.x + 15, this.y + 50, 'speed', 10);
                    }
                }

                // Update double jump indicator
                if (!this.onG && !this.hasUsedDoubleJump) {
                    document.getElementById('jump-indicator').classList.add('show');
                } else {
                    document.getElementById('jump-indicator').classList.remove('show');
                }

                // Combat
                const shootPressed = input.justPressed('KeyX');

                if (shootPressed && this.shootCd <= 0) {
                    const snowSize = 5;
                    const snowSpeed = 10;
                    this.snowballs.push({
                        x: this.x + 15,
                        y: this.y + 25,
                        vx: this.dir * snowSpeed,
                        vy: -2,
                        life: 60,
                        size: snowSize,
                        powered: false
                    });
                    this.shootCd = 20;
                    audio.playSfx('shoot');
                }

                if (this.shootCd > 0) this.shootCd--;
                if (this.invincible > 0) this.invincible--;
                if (this.comboTimer > 0) {
                    this.comboTimer--;
                    if (this.comboTimer === 0) this.combo = 0;
                }

                this.vy += GRAVITY;
                this.x += this.vx;
                this.collide(world, 'x');
                this.y += this.vy;
                this.collide(world, 'y');

                if (!this.onG) this.state = 'jumping';
                this.animT += 0.016;

                this.snowballs = this.snowballs.filter(s => {
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += 0.2;
                    s.life--;
                    return s.life > 0 && s.y < 800;
                });


            }

            collide(world, axis) {
                if (axis === 'y') this.onG = false;
                for (const p of world.platforms) {
                    if (this.x < p.x + p.w && this.x + this.w > p.x && this.y < p.y + p.h && this.y + this.h > p.y) {
                        if (axis === 'x') {
                            this.x = this.vx > 0 ? p.x - this.w : p.x + p.w;
                            this.vx = 0;
                        }
                        else {
                            if (this.vy > 0) {
                                this.y = p.y - this.h;
                                this.onG = true;
                                this.vy = 0;
                            } else {
                                this.y = p.y + p.h;
                                this.vy = 0;
                            }
                        }
                    }
                }
            }

            takeDamage() {
                if (this.invincible > 0) return false;
                if (this.hasShield > 0) {
                    this.hasShield = 0;
                    audio.playSfx('power');
                    return false;
                }

                this.health--;
                this.invincible = 120;
                this.levelDamageTaken++;
                audio.playSfx('hurt');

                const hearts = document.querySelectorAll('.heart');
                if (hearts[this.health]) {
                    hearts[this.health].classList.add('lost');
                }

                return this.health <= 0;
            }

            addScore(points, particles, x, y) {
                this.combo++;
                this.comboTimer = COMBO_TIMEOUT / 16.67;

                const multiplier = Math.min(this.combo, 5);
                const finalPoints = points * multiplier;

                const scoreEl = document.getElementById('score');
                const currentScore = parseInt(scoreEl.innerText);
                scoreEl.innerText = currentScore + finalPoints;
                scoreEl.classList.add('score-pulse');
                setTimeout(() => scoreEl.classList.remove('score-pulse'), 400);

                if (this.combo >= 3) {
                    const comboEl = document.getElementById('combo-display');
                    comboEl.innerText = `COMBO x${this.combo}!`;
                    comboEl.classList.remove('show');
                    void comboEl.offsetWidth;
                    comboEl.classList.add('show');
                    setTimeout(() => comboEl.classList.remove('show'), 1000);
                }

                particles.emit(x, y, 'collect', 10);

                return currentScore + finalPoints;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 800;
                this.canvas.height = 600;

                // Speed lines canvas
                this.speedCanvas = document.getElementById('speedCanvas');
                this.speedCtx = this.speedCanvas.getContext('2d');

                this.input = new Input();
                this.player = new Player(100, 400);
                this.particles = new ParticleSystem();
                this.achievements = new AchievementSystem();
                this.cam = { x: 0, y: 0, z: 1 };
                this.score = 0;
                this.level = 0;
                this.won = false;
                this.gameOver = false;
                this.snowParticles = [];
                this.gameStarted = false;
                this.levelStartTime = 0;
                this.totalTime = 0;

                this.levels = [
                    {
                        name: 'SNOW VILLAGE',
                        platforms: [
                            { x: 0, y: 550, w: 2000, h: 50 },
                            { x: 400, y: 400, w: 200, h: 30 },
                            { x: 700, y: 250, w: 200, h: 30 },
                            { x: 1100, y: 400, w: 300, h: 30 },
                            { x: 1500, y: 300, w: 200, h: 30 }
                        ],
                        items: [
                            { x: 450, y: 350, t: 'star' },
                            { x: 750, y: 200, t: 'star' },
                            { x: 1200, y: 350, t: 'bell' },
                            { x: 1600, y: 250, t: 'gift' }
                        ],
                        powerups: [
                            { x: 550, y: 350, t: 'speed' },
                            { x: 1350, y: 350, t: 'shield' }
                        ],
                        enemies: [
                            { x: 600, y: 500, v: -1.5, f: 0 },
                            { x: 1300, y: 500, v: -1.5, f: 0 }
                        ],
                        goal: { x: 1800, y: 550 }
                    },
                    {
                        name: 'FROZEN LAKE',
                        platforms: [
                            { x: 0, y: 550, w: 3000, h: 50, s: true },
                            { x: 500, y: 450, w: 300, h: 30, s: true },
                            { x: 900, y: 350, w: 300, h: 30, s: true },
                            { x: 1300, y: 250, w: 300, h: 30, s: true },
                            { x: 1800, y: 400, w: 500, h: 30, s: true }
                        ],
                        items: [
                            { x: 550, y: 400, t: 'gift' },
                            { x: 950, y: 300, t: 'star' },
                            { x: 1100, y: 300, t: 'bell' },
                            { x: 1500, y: 200, t: 'star' },
                            { x: 2000, y: 350, t: 'gift' }
                        ],
                        powerups: [
                            { x: 700, y: 400, t: 'freeze' },
                            { x: 1450, y: 200, t: 'speed' },
                            { x: 2100, y: 350, t: 'shield' }
                        ],
                        enemies: [
                            { x: 800, y: 500, v: -2, f: 0 },
                            { x: 1600, y: 500, v: -2, f: 0 },
                            { x: 2200, y: 500, v: -2, f: 0 }
                        ],
                        goal: { x: 2700, y: 550 }
                    },
                    {
                        name: 'XMAS FOREST',
                        platforms: [
                            { x: 0, y: 550, w: 400, h: 50 },
                            { x: 300, y: 450, w: 150, h: 30 },
                            { x: 150, y: 350, w: 150, h: 30 },
                            { x: 350, y: 250, w: 150, h: 30 },
                            { x: 600, y: 200, w: 200, h: 30 },
                            { x: 900, y: 300, w: 200, h: 30 },
                            { x: 1200, y: 400, w: 1000, h: 30 }
                        ],
                        items: [
                            { x: 360, y: 200, t: 'star' },
                            { x: 650, y: 150, t: 'bell' },
                            { x: 950, y: 250, t: 'gift' },
                            { x: 1500, y: 350, t: 'star' },
                            { x: 1800, y: 350, t: 'bell' }
                        ],
                        powerups: [
                            { x: 200, y: 300, t: 'shield' },
                            { x: 700, y: 150, t: 'speed' },
                            { x: 1600, y: 350, t: 'freeze' }
                        ],
                        enemies: [
                            { x: 1300, y: 350, v: -2, f: 0 },
                            { x: 1700, y: 350, v: -2, f: 0 },
                            { x: 1900, y: 350, v: -1.5, f: 0 }
                        ],
                        goal: { x: 2000, y: 400 }
                    }
                ];

                // Initialize world with first level to prevent undefined errors
                this.world = this.levels[0];

                requestAnimationFrame(t => this.loop());
            }

            startGame() {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('victory-screen').style.display = 'none';
                this.gameStarted = true;
                this.won = false;
                this.gameOver = false;
                this.score = 0;
                this.totalTime = 0;
                document.getElementById('score').innerText = '0';
                this.achievements.unlocked.clear();
                this.loadLevel(0);
            }

            loadLevel(i) {
                this.level = i;
                this.world = this.levels[i];
                this.player.reset(100, 400);
                this.player.invincible = 60;
                this.levelStartTime = Date.now();

                document.querySelectorAll('.heart').forEach(h => h.classList.remove('lost'));

                document.getElementById('level-name').innerText = this.world.name;
                document.getElementById('level-num').innerText = i + 1;
            }

            formatTime(ms) {
                const seconds = Math.floor(ms / 1000);
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }

            update() {
                if (!this.gameStarted || this.won || this.gameOver) {
                    // Draw speed lines even when paused
                    if (this.player.speedBoost > 0) {
                        this.drawSpeedLines();
                    }
                    return;
                }

                this.player.update(this.input, this.world, this.particles, this.achievements);
                this.particles.update();

                // Update timer
                const levelTime = Date.now() - this.levelStartTime;
                const timerEl = document.getElementById('timer-display');
                timerEl.innerText = '‚è±Ô∏è ' + this.formatTime(levelTime);

                // Warning at 60 seconds
                if (levelTime > 60000) {
                    timerEl.classList.add('warning');
                } else {
                    timerEl.classList.remove('warning');
                }

                // Camera
                this.cam.x = lerp(this.cam.x, this.player.x - 400 / this.cam.z, 0.08);
                this.cam.y = lerp(this.cam.y, this.player.y - 300 / this.cam.z, 0.08);

                let targetZoom = 1.0;
                if (this.player.y < 100) targetZoom = 0.85;
                this.cam.z = lerp(this.cam.z, targetZoom, 0.03);

                if (this.cam.x < 0) this.cam.x = 0;

                // Fall Death
                if (this.player.y > 800) {
                    if (this.player.takeDamage()) {
                        this.gameOver = true;
                        document.getElementById('game-over-screen').style.display = 'flex';
                        document.getElementById('gameover-score').innerText = document.getElementById('score').innerText;
                        document.getElementById('gameover-level').innerText = this.level + 1;
                    } else {
                        this.player.x = 100;
                        this.player.y = 400;
                        this.player.vx = 0;
                        this.player.vy = 0;
                    }
                    return;
                }

                // Item Collection
                let allItemsCollected = true;
                this.world.items.forEach(it => {
                    if (!it.c) {
                        allItemsCollected = false;
                        if (Math.abs(this.player.x - it.x) < 40 && Math.abs(this.player.y - it.y) < 60) {
                            it.c = true;

                            let points = 100;
                            if (it.t === 'bell') {
                                points = 500;
                            }
                            if (it.t === 'gift') {
                                points = 200;
                            }
                            if (it.t === 'star') {
                                points = 500;
                            }

                            this.score = this.player.addScore(points, this.particles, it.x, it.y);
                            audio.playSfx('collect', 1 + this.player.combo * 0.1);

                            if (this.player.combo >= 5) {
                                this.achievements.unlock('combo_master');
                            }
                        }
                    }
                });

                // Powerup Collection
                this.world.powerups.forEach(pu => {
                    if (!pu.c && Math.abs(this.player.x - pu.x) < 40 && Math.abs(this.player.y - pu.y) < 60) {
                        pu.c = true;
                        audio.playSfx('powerup');
                        this.particles.emit(pu.x, pu.y, pu.t, 20);

                        if (pu.t === 'speed') {
                            this.player.speedBoost = 300; // 5 seconds
                        } else if (pu.t === 'shield') {
                            this.player.hasShield = 600; // 10 seconds
                        } else if (pu.t === 'freeze') {
                            this.world.enemies.forEach(e => e.f = 300);
                        }
                    }
                });

                // Enemy Update
                let firstKill = false;
                this.world.enemies.forEach(e => {
                    if (e.f > 0) {
                        e.f--;
                    } else {
                        e.x += e.v;
                        let g = false;
                        for (const p of this.world.platforms) {
                            if (e.x < p.x + p.w && e.x + 40 > p.x && e.y + 50 > p.y && e.y + 50 < p.y + 10) {
                                e.y = p.y - 50;
                                g = true;
                                break;
                            }
                        }
                        if (!g || e.x < 0 || e.x > this.world.goal.x + 200) e.v *= -1;

                        if (Math.abs(this.player.x - e.x) < 50 && Math.abs(this.player.y - e.y) < 70) {
                            if (this.player.takeDamage()) {
                                this.gameOver = true;
                                document.getElementById('game-over-screen').style.display = 'flex';
                                document.getElementById('gameover-score').innerText = document.getElementById('score').innerText;
                                document.getElementById('gameover-level').innerText = this.level + 1;
                            } else {
                                this.player.vx = (this.player.x < e.x ? -1 : 1) * 10;
                                this.player.vy = -8;
                                this.particles.emit(this.player.x + 15, this.player.y + 25, 'hurt', 15);
                            }
                        }
                    }

                    this.player.snowballs.forEach(s => {
                        if (Math.abs(s.x - (e.x + 20)) < 30 && Math.abs(s.y - (e.y + 30)) < 30) {
                            if (!e.killed) {
                                e.killed = true;
                                firstKill = true;
                            }
                            e.f = 300;
                            s.life = 0;
                            this.score = this.player.addScore(200, this.particles, e.x + 20, e.y + 30);
                            this.particles.emit(e.x + 20, e.y + 30, 'collect', 15);
                        }
                    });
                });

                if (firstKill) this.achievements.unlock('first_blood');

                // Snow particles
                if (Math.random() < 0.3) {
                    this.snowParticles.push({
                        x: Math.random() * 1000 + this.cam.x - 100,
                        y: this.cam.y - 100,
                        vy: Math.random() * 2 + 1,
                        vx: Math.random() * 0.5 - 0.25,
                        s: Math.random() * 3 + 1
                    });
                }
                this.snowParticles.forEach(p => {
                    p.y += p.vy;
                    p.x += p.vx;
                });
                this.snowParticles = this.snowParticles.filter(p => p.y < this.cam.y + 700);

                // Goal Check
                const distToGoal = Math.sqrt((this.player.x - this.world.goal.x) ** 2 + (this.player.y - this.world.goal.y + 50) ** 2);
                if (distToGoal < 60) {
                    const levelTime = Date.now() - this.levelStartTime;
                    this.totalTime += levelTime;

                    // Check achievements
                    if (levelTime < 30000) {
                        this.achievements.unlock('speed_demon');
                    }
                    if (this.player.levelDamageTaken === 0) {
                        this.achievements.unlock('no_damage');
                    }
                    if (allItemsCollected) {
                        this.achievements.unlock('collector');
                    }
                    if (this.player.health === 1) {
                        this.achievements.unlock('survivor');
                    }

                    if (this.level < 2) {
                        this.loadLevel(this.level + 1);
                        audio.playSfx('collect');
                    } else {
                        this.won = true;
                        this.showVictory();
                    }
                }
            }

            showVictory() {
                document.getElementById('victory-screen').style.display = 'flex';
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('final-time').innerText = this.formatTime(this.totalTime);

                // Time bonus
                const targetTime = 90000; // 1:30 per level * 3
                if (this.totalTime < targetTime) {
                    const bonus = Math.floor((targetTime - this.totalTime) / 100);
                    document.getElementById('time-bonus').innerHTML =
                        `<div style="color: #00d2ff; margin-top: 10px;">‚ö° TIME BONUS: +${bonus} pts</div>`;
                    this.score += bonus;
                    document.getElementById('final-score').innerText = this.score;
                }

                // Show achievements
                const achList = document.getElementById('achievement-list');
                const unlockedAchs = this.achievements.getUnlocked();
                if (unlockedAchs.length > 0) {
                    achList.innerHTML = '<h3 style="color: #ffd700; font-size: 24px; margin: 10px 0;">Achievements Unlocked:</h3>';
                    unlockedAchs.forEach(ach => {
                        achList.innerHTML += `<div style="margin: 5px 0;">${ach.name}</div>`;
                    });
                } else {
                    achList.innerHTML = '';
                }

                audio.playSfx('victory');
            }

            drawSpeedLines() {
                const ctx = this.speedCtx;
                ctx.clearRect(0, 0, 800, 600);

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;

                for (let i = 0; i < 10; i++) {
                    const y = (Date.now() / 20 + i * 60) % 600;
                    const offset = Math.sin(y / 100) * 50;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(100 + offset, y);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(800, y);
                    ctx.lineTo(700 + offset, y);
                    ctx.stroke();
                }
            }

            render() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, 800, 600);

                if (!this.world) return; // Safety check

                ctx.save();
                ctx.translate(400, 300);
                ctx.scale(this.cam.z, this.cam.z);
                ctx.translate(-400 - this.cam.x, -300 - this.cam.y);

                Renderer.drawBackground(ctx, this.cam, this.level);

                this.world.platforms.forEach(p => Renderer.drawPlatform(ctx, p.x, p.y, p.w, p.h, p.s));

                this.world.items.forEach(it => {
                    if (!it.c) Renderer.drawItem(ctx, it.x, it.y + Math.sin(Date.now() / 200 + it.x) * 5, it.t);
                });

                this.world.powerups.forEach(pu => {
                    if (!pu.c) Renderer.drawPowerup(ctx, pu.x, pu.y + Math.sin(Date.now() / 300 + pu.x) * 8, pu.t);
                });

                this.world.enemies.forEach(e => Renderer.drawSnowman(ctx, e.x + 20, e.y + 50, 50, e.f > 0));

                this.player.snowballs.forEach(s => {
                    ctx.save();
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#fff';
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });

                const distToGoal = Math.sqrt((this.player.x - this.world.goal.x) ** 2 + (this.player.y - this.world.goal.y + 50) ** 2);
                Renderer.drawCabin(ctx, this.world.goal.x, this.world.goal.y, distToGoal < 150);

                if (this.player.invincible === 0 || Math.floor(this.player.invincible / 5) % 2 === 0) {
                    Renderer.drawSanta(ctx, this.player.x + 15, this.player.y + 50, this.player.dir,
                        this.player.state, this.player.animT, this.player.hasShield > 0);
                }

                this.particles.render(ctx, this.cam);

                ctx.restore();

                // Snow overlay
                ctx.fillStyle = '#fff';
                this.snowParticles.forEach(p => {
                    const screenX = (p.x - this.cam.x) * this.cam.z + 400;
                    const screenY = (p.y - this.cam.y) * this.cam.z + 300;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, p.s * this.cam.z, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;

                // Speed lines
                if (this.player.speedBoost > 0) {
                    this.drawSpeedLines();
                }
            }

            loop() {
                this.update();
                this.render();
                requestAnimationFrame(t => this.loop());
            }
        }

        let game;
        window.onload = () => {
            game = new Game();

            // Fullscreen: full game (container) goes fullscreen; game area fills viewport
            const fsBtn = document.getElementById('btn-fullscreen');
            const gameContainer = document.getElementById('game-container');
            const enterFS = () => {
                try {
                    if (gameContainer.requestFullscreen) gameContainer.requestFullscreen();
                    else if (gameContainer.webkitRequestFullscreen) gameContainer.webkitRequestFullscreen();
                    else if (gameContainer.msRequestFullscreen) gameContainer.msRequestFullscreen();
                } catch (_) { }
            };
            const exitFS = () => {
                try {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                    else if (document.msExitFullscreen) document.msExitFullscreen();
                } catch (_) { }
            };
            const updateFsLabel = () => {
                const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
                fsBtn.textContent = isFs ? '‚äü' : '‚õ∂';
                fsBtn.title = isFs ? 'Exit full screen' : 'Full screen';
                fsBtn.setAttribute('aria-label', isFs ? 'Exit full screen' : 'Full screen');
            };
            fsBtn.addEventListener('click', () => {
                const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
                if (isFs) exitFS(); else enterFS();
            });
            // Prevent Space/Enter from toggling fullscreen so Space stays for jump
            fsBtn.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') e.preventDefault();
                if (e.code === 'Enter' || e.key === 'Enter') e.preventDefault();
            });
            document.addEventListener('fullscreenchange', updateFsLabel);
            document.addEventListener('webkitfullscreenchange', updateFsLabel);
            document.addEventListener('MSFullscreenChange', updateFsLabel);
        };
    </script>
</body>

</html>